// Generated by CoffeeScript 1.3.3
(function() {
  var AnimateMaze, Maze, Node, Queue, load_maze;

  Maze = (function() {

    function Maze(maze) {
      this.maze = maze;
      this.maze = this.maze.split("\n");
      this.start = null;
      this.end = null;
      this.height = this.maze.length;
      this.width = this.maze[0].length;
      this.queue = new Queue;
      this.animate = new AnimateMaze;
    }

    Maze.prototype.solve = function() {
      this.find_start();
      return this.explorer();
    };

    Maze.prototype.find_start = function() {
      var col_index, position, row, row_index, _i, _len, _ref, _results;
      _ref = this.maze;
      _results = [];
      for (row_index = _i = 0, _len = _ref.length; _i < _len; row_index = ++_i) {
        row = _ref[row_index];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (col_index = _j = 0, _len1 = row.length; _j < _len1; col_index = ++_j) {
            position = row[col_index];
            switch (position) {
              case "#":
                _results1.push(this.animate.draw(row_index, col_index, "border"));
                break;
              case " ":
                _results1.push(this.animate.draw(row_index, col_index, "space"));
                break;
              case "A":
                this.start = new Node(row_index, col_index, null, 0, "start");
                this.queue.process.unshift(this.start);
                _results1.push(this.animate.draw(row_index, col_index, "start"));
                break;
              case "B":
                _results1.push(this.animate.draw(row_index, col_index, "end"));
                break;
              default:
                _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Maze.prototype.explorer = function() {
      if ((typeof this.has_found_end === "function" ? this.has_found_end() : void 0) && (typeof this.more_to_process === "function" ? this.more_to_process() : void 0)) {
        return this.eval_current_node(this.queue.process.shift());
      } else {
        if (this.end !== null) {
          this.animate.draw(this.end.y, this.end.x, "end");
          this.shortest_path();
          $('#steps').html("The shortest path is " + this.end.steps + " steps.");
        } else {
          $('#steps').html("Sorry, no solution exists. :(");
        }
        return this.animate.draw_paths();
      }
    };

    Maze.prototype.has_found_end = function() {
      return this.end === null;
    };

    Maze.prototype.more_to_process = function() {
      return this.queue.process.length !== 0;
    };

    Maze.prototype.eval_current_node = function(node) {
      this.animate.history.push(new Node(node.y, node.x, node.steps, "processed"));
      if (this.maze[node.y + 1].charAt(node.x) !== '#' && this.not_processed(node.y + 1, node.x) && this.end === null) {
        this.enqueue_node(new Node(node.y + 1, node.x, node, node.steps + 1, "process"));
        this.is_end_node();
      }
      if (this.maze[node.y - 1].charAt(node.x) !== '#' && this.not_processed(node.y - 1, node.x) && this.end === null) {
        this.enqueue_node(new Node(node.y - 1, node.x, node, node.steps + 1, "process"));
        this.is_end_node();
      }
      if (this.maze[node.y].charAt(node.x + 1) !== '#' && this.not_processed(node.y, node.x + 1) && this.end === null) {
        this.enqueue_node(new Node(node.y, node.x + 1, node, node.steps + 1, "process"));
        this.is_end_node();
      }
      if (this.maze[node.y].charAt(node.x - 1) !== '#' && this.not_processed(node.y, node.x - 1) && this.end === null) {
        this.enqueue_node(new Node(node.y, node.x - 1, node, node.steps + 1, "process"));
        this.is_end_node();
      }
      this.queue.processed.push(node);
      return this.explorer();
    };

    Maze.prototype.not_processed = function(y, x) {
      var node, not_found, _i, _len, _ref;
      not_found = true;
      _ref = this.queue.processed;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node.y === y && node.x === x) {
          not_found = false;
        }
      }
      return not_found;
    };

    Maze.prototype.enqueue_node = function(node) {
      this.animate.history.push(node);
      return this.queue.process.push(node);
    };

    Maze.prototype.is_end_node = function() {
      var last_index, last_node;
      last_index = this.queue.process.length - 1;
      last_node = this.queue.process[last_index];
      if (this.maze[last_node.y].charAt(last_node.x) === "B") {
        this.end = last_node;
        return this.animate.history.push(new Node(last_node.y, last_node.x, last_node.parent, last_node.steps, "end"));
      }
    };

    Maze.prototype.shortest_path = function() {
      var node, _results;
      node = this.end;
      node.state = "end";
      _results = [];
      while (node.parent !== null) {
        this.animate.solution.push(node);
        _results.push(node = node.parent);
      }
      return _results;
    };

    return Maze;

  })();

  AnimateMaze = (function() {

    function AnimateMaze() {
      this.ctx = document.getElementById("maze_solution").getContext("2d");
      this.history = [];
      this.solution = [];
    }

    AnimateMaze.prototype.draw = function(y, x, element) {
      switch (element) {
        case "border":
          this.ctx.clearRect(x * 20, y * 20, 20, 20);
          this.ctx.fillStyle = "rgb(215,129,6)";
          return this.ctx.fillRect(x * 20, y * 20, 20, 20);
        case " ":
          this.ctx.clearRect(x * 20, y * 20, 20, 20);
          this.ctx.fillStyle = "rgb(1,1,1)";
          return this.ctx.fillRect(x * 20, y * 20, 20, 20);
        case "process":
          this.ctx.clearRect(x * 20, y * 20, 20, 20);
          this.ctx.fillStyle = "rgb(50,50,50)";
          return this.ctx.fillRect(x * 20, y * 20, 20, 20);
        case "processed":
          this.ctx.clearRect(x * 20, y * 20, 20, 20);
          this.ctx.fillStyle = "rgb(100,100,100)";
          return this.ctx.fillRect(x * 20, y * 20, 20, 20);
        case "start":
          this.ctx.clearRect(x * 20, y * 20, 20, 20);
          this.ctx.fillStyle = "rgb(45,123,200)";
          return this.ctx.fillRect(x * 20, y * 20, 20, 20);
        case "end":
          this.ctx.clearRect(x * 20, y * 20, 20, 20);
          this.ctx.fillStyle = "rgb(200,45,45)";
          return this.ctx.fillRect(x * 20, y * 20, 20, 20);
        case "solution":
          this.ctx.clearRect(x * 20, y * 20, 20, 20);
          this.ctx.fillStyle = "rgb(153,102,255)";
          return this.ctx.fillRect(x * 20, y * 20, 20, 20);
      }
    };

    AnimateMaze.prototype.draw_paths = function() {
      var node, state,
        _this = this;
      if (node = this.history.shift()) {
        this.draw(node.y, node.x, node.state);
        return window.setTimeout(function() {
          return _this.draw_paths();
        }, 25);
      } else if (node = this.solution.pop()) {
        if (node.state !== "end") {
          state = "solution";
        } else {
          state = "end";
        }
        this.draw(node.y, node.x, state);
        return window.setTimeout(function() {
          return _this.draw_paths();
        }, 25);
      }
    };

    return AnimateMaze;

  })();

  Queue = (function() {

    function Queue() {
      this.process = [];
      this.processed = [];
    }

    return Queue;

  })();

  Node = (function() {

    function Node(y, x, parent, steps, state) {
      this.y = y;
      this.x = x;
      this.parent = parent;
      this.steps = steps;
      this.state = state;
      this.y = this.y;
      this.x = this.x;
      this.parent = this.parent;
      this.steps = this.steps;
      this.state = this.state;
    }

    return Node;

  })();

  $(document).ready(function() {
    return $('button').click(function() {
      var id;
      id = $(this).attr("id");
      document.getElementById("maze_solution").getContext("2d").clearRect(0, 0, 800, 800);
      return load_maze(parseInt(id));
    });
  });

  load_maze = function(num) {
    var maze;
    maze = new Maze($('textarea[maze=' + num + ']').val());
    return maze.solve();
  };

}).call(this);
